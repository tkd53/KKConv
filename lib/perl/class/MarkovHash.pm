#=====================================================================================
#                       MarkovHash.pm
#                             bShinsuke Mori
#                             Last change 13 March 2016
#=====================================================================================

# ��  ǽ : ñ���ޥ륳�ե��ǥ����ϥå������Ѥ��Ƽ������롣
#
# ��  �� : �ʤ�
#
# ������ : �����󤫤��ϥå��奭���ؤδؿ���Ϣ�ܤǤ��ꡢ���줬ñ�ͤȤʤ�ɬ�פ����롣


#-------------------------------------------------------------------------------------
#                        declalations
#-------------------------------------------------------------------------------------

require "class/Markov.pm";

package MarkovHash;
@ISA = qw( Markov );

use Carp;
use POSIX;
use DB_File;
#use BerkeleyDB;


#-------------------------------------------------------------------------------------
#                        set variables
#-------------------------------------------------------------------------------------

$SUFFIX = ".db";                                # �ե�����̾�γ�ĥ��


#-------------------------------------------------------------------------------------
#                        new
#-------------------------------------------------------------------------------------

# new(IntStr, SIZE, FILE)
#
# ��  ǽ : �ޥ륳�ե��ǥ��Τ����Υϥå������������롣

sub new{
    (@_ == 2) || (@_ == 3) || die;
    my($type, $size, $FILE) = @_;
#    printf(STDERR "%s::new(%d, %s)\n", $type, $size, $FILE);

    my($self) = {};

    $$self{"_size_"} = $size;

    bless($self);

    $self->get($FILE) if (defined($FILE));

    return($self);
}


#-------------------------------------------------------------------------------------
#                        add
#-------------------------------------------------------------------------------------

# add(Int, STATE, STATE);
#
# ��  ǽ : <STATE, STATE> �����٤� Int ���ä��롣

sub add{
    (@_ == 4) || die;
    my($self, $val) = (shift, shift);

    for (push(@_, 0); @_ > 0; shift){
        $$self{pack("I" x scalar(@_), @_)} += $val;
    }

    return($self);
}


#-------------------------------------------------------------------------------------
#                        rep
#-------------------------------------------------------------------------------------

# rep(Int, STATE, STATE);
#
# ��  ǽ : <STATE, STATE> �����٤� Int �ˤ��롣

sub rep{
    ((2 <= @_) && (@_ <= 4)) || die;
    my($self, $val) = (shift, shift);

#    if (scalar(@_) == 0){
#        printf(STDERR "0 rep(%f)\n", $val);
#    }
#    if (scalar(@_) == 1){
#        printf(STDERR "1 rep(%f, %d)\n", $val, @_);
#    }
#    if (scalar(@_) == 2){
#        printf(STDERR "2 rep(%f, %d, %d)\n", $val, @_);
#    }

    push(@_, 0);
    $$self{pack("I" x scalar(@_), @_)} = $val;

    return($self);
}


#-------------------------------------------------------------------------------------
#                        inc
#-------------------------------------------------------------------------------------

# inc(STATE, STATE);
#
# ��  ǽ : <STATE, STATE> �����٤򥤥󥯥������Ȥ��롣

sub inc{
    (@_ == 3) || die;
    my($self) = shift;

    for (push(@_, 0); @_ > 0; shift){
        $$self{pack("I" x scalar(@_), @_)}++;
    }

    return($self);
}


#-------------------------------------------------------------------------------------
#                        size
#-------------------------------------------------------------------------------------

# size;
#
# ��  ǽ : size ���֤���

sub size{
#    warn "MarkovHash::size()\n";
    (@_ == 1) || die;
    my($self) = @_;

    return($$self{"_size_"});
}


#-------------------------------------------------------------------------------------
#                        _0gram
#-------------------------------------------------------------------------------------

# _0gram
#
# ��  ǽ : 0-gram ������

sub _0gram{
    (@_ == 1) || die;
    my($self) = shift;

    return($$self{pack("I" x 1, (@_, 0))});
}


#-------------------------------------------------------------------------------------
#                        _1gram
#-------------------------------------------------------------------------------------

# _1gram(Number)
#
# ��  ǽ : 1-gram ������
#          Number : ���֤��ֹ�

sub _1gram{
    (@_ == 2) || die;
    my($self) = shift;

    return($$self{pack("I" x 2, (@_, 0))});
}


#-------------------------------------------------------------------------------------
#                        _2gram
#-------------------------------------------------------------------------------------

# _2gram(Number, Number)
#
# ��  ǽ : 2-gram ������
#          Number : ���֤��ֹ�

sub _2gram{
    (@_ == 3) || croak;
    my($self) = shift;

    return($$self{pack("I" x 3, (@_, 0))});
}


#-------------------------------------------------------------------------------------
#                        put
#-------------------------------------------------------------------------------------

# put(FILENAME);
#
# ��  ǽ : �ե������˽��Ϥ��롣

sub put{
    (@_ == 2) || die;
    my($self, $FILE) = @_;

    my($HASH) = $FILE . $SUFFIX;
    (-e $HASH) && unlink($HASH);
    tie(%hash, DB_File, $HASH, O_CREAT|O_RDWR) || die "Can't open $HASH: $!\n";
#    tie(%hash, BerkeleyDB::Hash, -Filename => $HASH, -Flags => DB_CREATE)
#        || die "Can't open $HASH: $!\n";
#    %hash = %$self;

    print STDERR "Writing $HASH ... ";
    $hash{$key} = $val while (($key, $val) = each(%$self));

# for Maeta BEGIN
    my($FREQ) = $FILE . ".freq";
    open(FREQ, "> $FREQ") || die "Can't open $FREQ: $!\n";
    while (($key, $val) = each(%$self)){
        printf(FREQ "%6d", $val);
        @stat = unpack("I" x (length($key)/4), $key);
        pop(@stat);                               # ���ߡ��ξõ�
        foreach $stat (@stat){
            printf(FREQ " %6d", $stat);
        }
        printf(FREQ "\n");
    }
    close(FREQ);
# for Maeta END

    print STDERR "Done\n";

    untie(%hash);

    return($self);
}


#-------------------------------------------------------------------------------------
#                        get
#-------------------------------------------------------------------------------------

# get(FILENAME);
#
# ��  ǽ : �ե����뤫�����Ϥ���

sub get{
    (@_ == 2) || die;
    my($self, $FILE) = @_;

    my($HASH) = $FILE . $SUFFIX;
    tie(%hash, DB_File, $HASH, 0) || die "Can't open $HASH: $!\n";
    $$self{$key} = $val while (($key, $val) = each(%hash));
    untie(%hash);

    return($self);
}


#-------------------------------------------------------------------------------------
#                        nonzero
#-------------------------------------------------------------------------------------

# nonzero();
#
# ��  ǽ : ������ 2-gram �����֤�

sub nonzero{
    (@_ == 1) || die;
    my($self) = @_;
    my($rval) = 0;

    while (($key, $val) = each(%$self)){
        (length($key) == 4*3) && $rval++;
    }

    return($rval);
}


#-------------------------------------------------------------------------------------
#                        UTcalc
#-------------------------------------------------------------------------------------

# UTcalc();
#
# ��  ǽ : f() ���� f(UT) �� f(w,UT) �� f(UT,w) ���׻����ޥ륳�ե��ǥ����������롣
#
# ��  �� : �Ȥ����Ƥ����Τ���

sub UTcalc{
    (@_ == 2) || die;
    my($self, $_0gram) = @_;

    %Prob = ();                                   # �ʻ� -> ��Ψ P(UTpos|UW)


    my($freq) = $_0gram-$self->_0gram();          # f(UW)
    while (($part, $prob) = each(%Prob)){
        $$self{pack("I" x 2, ($part, 0))} = $freq*$prob;
    }


    for ($m1 = @Part+2; $m1 < $intstr->size(); $m1++){
# kokokara

        my($freq) = $_0gram-$self->_0gram();          # f(m1|UW)
        while (($part, $prob) = each(%Prob)){
            $$self{pack("I" x 2, ($part, 0))} = $freq*$prob;
        }
    }


    $$self{pack("I" x scalar(@stat), @stat)} += $val;


    while (($key, $val) = each(%$self)){
        (length($key) == 4*3) && $rval++;
    }

    return($rval);
}


#-------------------------------------------------------------------------------------
#                        return
#-------------------------------------------------------------------------------------

1;


#=====================================================================================
#                        END
#=====================================================================================
