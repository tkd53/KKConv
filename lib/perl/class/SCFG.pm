#=====================================================================================
#                        SCFG.pm
#                             by Shinsuke MORI
#                             Last change : 21 October 1997
#=====================================================================================

# 機  能 : 確率文脈自由文法を実装するための仮想基底クラス
#
# 実  例 : なし
#
# 注意点 : 以下のようなチョムスキー標準系と開始記号からの単位生成規則を仮定している。
#
#            Sent => NTx         (タイプ 1)
#             NTx => NTy NTz     (タイプ 2)
#
#          低頻度事象に対処するため生成規則の確率は等確率分布と補間する。
#
#            P = λ1×Puniform ＋λ2×P(生成規則)
#
#            P(生成規則) = N(左辺 => 右辺)/N(左辺)
#
#          ただし N(左辺) = 0 の場合は (λ1, λ2) = (1, 0) に固定する。
#
#          等確率分布は以下の通り。
#
#            Puniform = 1/NonT                 if 左辺 = Sent (タイプ 1 の場合)
#                       1/(NonT×2×2×2)      otherwise      (タイプ 2 の場合)
#                       (×2 は右辺の右側の非終端記号の dnum や vnum や knum の曖昧性)
#
#          ここで NonT は開始記号を除いた非終端記号の数である。


#-------------------------------------------------------------------------------------
#                        declalations
#-------------------------------------------------------------------------------------

package SCFG;

use Carp;


#-------------------------------------------------------------------------------------
#                        set variables
#-------------------------------------------------------------------------------------


#-------------------------------------------------------------------------------------
#                        new
#-------------------------------------------------------------------------------------

# new(IntStr, FILE)
#
# 機  能 : インスタンスの生成
#            IntStr : 文字列と数値の対応関数
#          FILENAME : ファイルの名前

sub new{
    croak "Virtual function SCFG::new called";
}


#-------------------------------------------------------------------------------------
#                        put
#-------------------------------------------------------------------------------------

# put(FILENAME);
#
# 機  能 : ファイルに出力する。

sub put{
    croak "Virtual function SCFG::put called";
}


#-------------------------------------------------------------------------------------
#                        get
#-------------------------------------------------------------------------------------

# get(FILENAME);
#
# 機  能 : ファイルから入力する

sub get{
    croak "Virtual function SCFG::get called";
}


#-------------------------------------------------------------------------------------
#                        _1gram
#-------------------------------------------------------------------------------------

# _1gram(LHS1)
#
# 機  能 : LHS1 が左辺に来る生成規則の頻度を返す。
#
#            N(LHS1) = Σ N(LHS1 =>α) を返す。
#                   α∈NT*
#

sub _1gram{
    croak "Virtual function SCFG::_1gram called";
}


#-------------------------------------------------------------------------------------
#                        _2gram
#-------------------------------------------------------------------------------------

# _2gram(LHS1, RHS1)
#
# 機  能 : LHS1 が左辺に、RHS1 が右辺に来る生成規則の頻度 N(LHS1 => RHS1) を返す。

sub _2gram{
    croak "Virtual function SCFG::_2gram called";
}


#-------------------------------------------------------------------------------------
#                        _3gram
#-------------------------------------------------------------------------------------

# _3gram(LHS1, RHS1, RHS2)
#
# 機  能 : LHS1 が左辺に、RHS1 RHS2 が右辺に来る生成規則の頻度 N(LHS1 => RHS1 RHS2) を
#          返す。

sub _3gram{
    croak "Virtual function SCFG::_3gram called";
}


#-------------------------------------------------------------------------------------
#                        size
#-------------------------------------------------------------------------------------

# size;
#
# 機  能 : size を返す。
#          いま(1997/08/15)のところ無意味。

sub size{
    croak "Virtual function SCFG::size called";
}


#-------------------------------------------------------------------------------------
#                        add
#-------------------------------------------------------------------------------------

# add(Int, STATE, STATE);
#
# 機  能 : <STATE, STATE> の頻度に Int を加える。

sub add{
    croak "Virtual function SCFG::add called";
}


#-------------------------------------------------------------------------------------
#                        inc
#-------------------------------------------------------------------------------------

# inc(STATE, STATE);
#
# 機  能 : <STATE, STATE> の頻度をインクリメントする。

sub inc{
    croak "Virtual function SCFG::inc called";
}


#-------------------------------------------------------------------------------------
#                        prob
#-------------------------------------------------------------------------------------

# prob(LHS1, RHS1, λ1, λ2);
# prob(LHS1, RHS1, RHS2, λ1, λ2);
#
# 機  能 : 補間した生成確率を返す。

sub prob{
#    printf(STDERR "NonT = %d\n", $NonT);
    if (@_ == 5){                                 # 開始記号からの単位生成規則
        my($self, $LHS1, $RHS1, $L1, $L2) = @_;

        my($Puniform) = 1/$NonT;                  # 一様分布
#        my($Puniform) = $self->_1prob($RHS1);     # new !! 09/04

        if ($self->_1gram($LHS1) == 0){
            return($Puniform);
        }else{
            return($L1*$Puniform+$L2*$self->_2prob($LHS1, $RHS1));
        }
    }
    if (@_ == 6){                                 # チョムスキー標準形の生成規則
        my($self, $LHS1, $RHS1, $RHS2, $L1, $L2) = @_;

        my($Puniform) = 1/$NonT;                  # 右辺第一項の曖昧性
#        my($Puniform) = $self->_1prob($RHS1);     # new !! 09/04

        $lhs1 = $main::NonTIntStr->str($LHS1);    # ad hoc
        ($LHSC, $LHSF, $LHSS, $LHSD, $LHSV, $LHSK) = split("-", $lhs1);
        $Puniform /= 2 if ($LHSD == $Dmax);       # Dmax = (Dmax-1)+1 or Dmax+1
        $Puniform /= 2 if ($LHSV == $Vmax);       # Vmax = (Vmax-1)+1 or Vmax+1

        if ($self->_1gram($LHS1) == 0){
            return($Puniform);
        }else{
            return($L1*$Puniform+$L2*$self->_3prob($LHS1, $RHS1, $RHS2));
        }
    }
    shift(@_);
    print STDERR join(" ", @_), "\n";
    die;
}


#-------------------------------------------------------------------------------------
#                        _1prob
#-------------------------------------------------------------------------------------

# _1prob(LHS1, RHS1);
#
# 機  能 : 単位生成規則の生成確率を返す

sub _1prob{
    (@_ == 2) || die;
    my($self, $RHS1) = @_;

    return($self->_1gram($RHS1)/$self->_0gram());
}


#-------------------------------------------------------------------------------------
#                        _2prob
#-------------------------------------------------------------------------------------

# _2prob(LHS1, RHS1);
#
# 機  能 : 単位生成規則の生成確率を返す

sub _2prob{
    (@_ == 3) || die;
    my($self, $LHS1, $RHS1) = @_;

    return($self->_2gram($LHS1, $RHS1)/$self->_1gram($LHS1));
}


#-------------------------------------------------------------------------------------
#                        _3prob
#-------------------------------------------------------------------------------------

# _3prob(LHS1, RHS1, RHS2);
#
# 機  能 : CNF の規則の生成確率を返す

sub _3prob{
    (@_ == 4) || die;
    my($self, $LHS1, $RHS1, $RHS2) = @_;

    return($self->_3gram($LHS1, $RHS1, $RHS2)/$self->_1gram($LHS1));
}


#-------------------------------------------------------------------------------------
#                        OneIteration
#-------------------------------------------------------------------------------------

# OneIteration(List, Lambda1, Lambda2)
#
# 機  能 : 補間係数推定の一回の繰り返し。

# 注意点 : List = [LHS1, RHS1, RHS2, Coef] or [LHS1, RHS1, Coef]
#
#          N(LHS1) = 0 のときは (λ1, λ2) = (1, 0) なので計算の必要はない。

sub OneIteration{
    (@_ == 4) || die;
    my($self, $list, $L1, $L2) = @_;
    
    (@$list > 0) || return($L1, $L2);             # Held-out Data がない場合

    my($LHS1, $RHS1, $RHS2, $Coef, $p1, $p2, $temp, $Puniform);
    my($Coef_sum, $L1_new, $L2_new) = (0, 0, 0);
    foreach (@$list){
        if (@$_ == 3){
            ($LHS1, $RHS1, $Coef) = @$_;
            ($self->_1gram($LHS1) > 0) || next;

            $Puniform = 1/$NonT;

            $p1 = $L1*$Puniform;
            $p2 = $L2*$self->_2prob($LHS1, $RHS1);

            $L1_new += $Coef*$p1/($p1+$p2);
            $L2_new += $Coef*$p2/($p1+$p2);
            $Coef_sum += $Coef;
        }else{
            ($LHS1, $RHS1, $RHS2, $Coef) = @$_;
            ($self->_1gram($LHS1) > 0) || next;

            $Puniform = 1/$NonT;                  # 右辺第一項の曖昧性
            $lhs1 = $main::NonTIntStr->str($LHS1); # ad hoc
            ($LHSC, $LHSF, $LHSS, $LHSD, $LHSV) = split("-", $lhs1);
            $Puniform /= 2 if ($LHSD == $Dmax);   # Dmax = (Dmax-1)+1 or Dmax+1
            $Puniform /= 2 if ($LHSV == $Vmax);   # Vmax = (Vmax-1)+1 or Vmax+1

            $p1 = $L1*$Puniform;
            $p2 = $L2*$self->_3prob($LHS1, $RHS1, $RHS2);

            $L1_new += $Coef*$p1/($p1+$p2);
            $L2_new += $Coef*$p2/($p1+$p2);
            $Coef_sum += $Coef;
        }
    }

    $L1_new /= $Coef_sum;
    $L2_new /= $Coef_sum;

    $temp = 1-($L1_new+$L2_new);
    $L1_new += $temp/2;
    $L2_new += $temp/2;

    return($L1_new, $L2_new);
}


#-------------------------------------------------------------------------------------
#                        test
#-------------------------------------------------------------------------------------

sub test{
    my($self, $IntStr) = (shift, shift);
    my(@nont) = map($IntStr->int($_), @_);

#    @_ = map($IntStr->str($_), @nont);

    printf(STDERR "Freq(%s) = %d\n", @_[0], $self->_1gram($nont[0]));

    if (@_ == 3){
        printf(STDERR "Freq(%s => %s %s) = %d\n", @_, $self->_3gram(@nont));
        return;
    }
    if (@_ == 2){
        printf(STDERR "Freq(%s => %s) = %d\n", @_, $self->_2gram(@nont));
#        printf(STDERR "Prob(%s => %s) = %8.6f\n", @_, $self->prob(@nont, @main::LforSCFG));
        return;
    }
    die;
}


#-------------------------------------------------------------------------------------
#                        return
#-------------------------------------------------------------------------------------

1;


#=====================================================================================
#                        END
#=====================================================================================
