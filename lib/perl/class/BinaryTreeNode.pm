#=====================================================================================
#                        BinaryTreeNode.pm
#                             by Shinsuke MORI
#                             Last change : 14 August 1997
#=====================================================================================

# 機  能 : 二分木の Node
#
# 実  例 : なし
#
# 注意点 : なし


#-------------------------------------------------------------------------------------
#                        require
#-------------------------------------------------------------------------------------


#-------------------------------------------------------------------------------------
#                        declalations
#-------------------------------------------------------------------------------------

package BinaryTreeNode;


#-------------------------------------------------------------------------------------
#                        set variables
#-------------------------------------------------------------------------------------


#-------------------------------------------------------------------------------------
#                        new
#-------------------------------------------------------------------------------------

# new(Lchild, Rchild, Data)
#
# 機  能 : Lchild, Rchild を左右の子とする二分木のノードを生成する。
#
# 実  例 : $Node = new BinraryTreeNode(\$data, \$lchild, \$rchild)
#
# 注意点 : なし

sub new{
    (@_ <= 4) || die;
    my($type) = shift;

#    (@_ == 2) && printf(STDERR "BTN::new(%s, %s)\n", $_[0], $_[1]->sprint);
#    (@_ == 3) && printf(STDERR "BTN::new(%s, %s, %s)\n", $_[0], $_[1]->data, $_[2]->data);

    my($self) = [@_];
    return(bless($self));
}


#-------------------------------------------------------------------------------------
#                        data
#-------------------------------------------------------------------------------------

# data;
#
# 機  能 : 附属するデータを返す。

sub data{
    (@_ == 1) || die;
    my($self) = @_;

    return($$self[0]);
}


#-------------------------------------------------------------------------------------
#                        Lchild
#-------------------------------------------------------------------------------------

# Lchild;
#
# 機  能 : 左の子ノードを返す。

sub Lchild{
    (@_ == 1) || die;
    my($self) = @_;

    return($$self[1]);
}


#-------------------------------------------------------------------------------------
#                        Rchild
#-------------------------------------------------------------------------------------

# Rchild;
#
# 機  能 : 右の子ノードを返す。

sub Rchild{
    (@_ == 1) || die;
    my($self) = @_;

    return($$self[2]);
}


#-------------------------------------------------------------------------------------
#                        isleaf
#-------------------------------------------------------------------------------------

# isleaf;
#
# 機  能 : 葉であれば真を返し、そうでなければ偽を返す。

sub isleaf{
    (@_ == 1) || die;
    my($self) = @_;

    return(!defined($self->Lchild) && !defined($self->Rchild));
}


#-------------------------------------------------------------------------------------
#                        sprint
#-------------------------------------------------------------------------------------

# sprint;
#
# 機  能 : インスタンスを文字列に変換する。

sub sprint{
    (@_ == 1) || die;
    my($self) = @_;

    return(sprintf("( %s%s%s )", $self->data,
                   (defined($self->Lchild) ? " " . $self->Lchild->sprint : ""),
                   (defined($self->Rchild) ? " " . $self->Rchild->sprint : "")));
}


#-------------------------------------------------------------------------------------
#                        print
#-------------------------------------------------------------------------------------

# print;
#
# 機  能 : インスタンスを表示する。

sub print{
    (@_ == 1) || die;
    my($self) = @_;

    printf("%s => ( %s %s )\n", $self->data,
           (defined($self->Lchild) ? $self->Lchild->sprint : undef),
           (defined($self->Rchild) ? $self->Rchild->sprint : undef));
    return($self);
}


#-------------------------------------------------------------------------------------
#                        return
#-------------------------------------------------------------------------------------

1;


#=====================================================================================
#                        END
#=====================================================================================
