#=====================================================================================
#                       Markov.pm
#                             bShinsuke Mori
#                             Last change 13 August 2009
#=====================================================================================

# 機  能 : マルコフモデルを実装するための仮想基底クラス
#
# 実  例 : なし
#
# 注意点 : なし


#-------------------------------------------------------------------------------------
#                        declalations
#-------------------------------------------------------------------------------------

package Markov;

use Carp;


#-------------------------------------------------------------------------------------
#                        set variables
#-------------------------------------------------------------------------------------


#-------------------------------------------------------------------------------------
#                        new
#-------------------------------------------------------------------------------------

# new(IntStr, SIZE, FILE)
#
# 機  能 : インスタンスの生成
#            IntStr : 文字列と数値の対応関数
#          FILENAME : ファイルの名前

sub new{
    croak "Virtual function Markov::new called";
}


#-------------------------------------------------------------------------------------
#                        put
#-------------------------------------------------------------------------------------

# put(FILENAME);
#
# 機  能 : ファイルに出力する。

sub put{
    croak "Virtual function Markov::put called";
}


#-------------------------------------------------------------------------------------
#                        get
#-------------------------------------------------------------------------------------

# get(FILENAME);
#
# 機  能 : ファイルから入力する

sub get{
    croak "Virtual function Markov::get called";
}


#-------------------------------------------------------------------------------------
#                        _0gram
#-------------------------------------------------------------------------------------

# _0gram
#
# 機  能 : 0-gram の頻度

sub _0gram{
    croak "Virtual function Markov::_0gram called";
}


#-------------------------------------------------------------------------------------
#                        _1gram
#-------------------------------------------------------------------------------------

# _1gram(Number)
#
# 機  能 : 1-gram の頻度
#          Number : 状態の番号

sub _1gram{
    croak "Virtual function Markov::_1gram called";
}


#-------------------------------------------------------------------------------------
#                        _2gram
#-------------------------------------------------------------------------------------

# _2gram(Number)
#
# 機  能 : 2-gram の頻度
#          Number : 状態の番号

sub _2gram{
    croak "Virtual function Markov::_2gram called";
}


#-------------------------------------------------------------------------------------
#                        size
#-------------------------------------------------------------------------------------

# size;
#
# 機  能 : size を返す。

sub size{
    croak "Virtual function Markov::size called";
}


#-------------------------------------------------------------------------------------
#                        add
#-------------------------------------------------------------------------------------

# add(Int, STATE, STATE);
#
# 機  能 : <STATE, STATE> の頻度に Int を加える。

sub add{
    croak "Virtual function Markov::add called";
}


#-------------------------------------------------------------------------------------
#                        inc
#-------------------------------------------------------------------------------------

# inc(STATE, STATE);
#
# 機  能 : <STATE, STATE> の頻度をインクリメントする。

sub inc{
    (@_ == 3) || die;
    my($self) = shift;

    $self->add(@_);
}


#-------------------------------------------------------------------------------------
#                        logP
#-------------------------------------------------------------------------------------

# logP(NUM, NUM, λ1, λ2);
#
# 機  能 : 補間した遷移確率を返す。

sub logP{
    (@_ == 5) || die;
    my($self, $suf1, $suf2, $L1, $L2) = @_;

    return(-log($L1*$self->_1prob($suf2)+$L2*$self->_2prob($suf1, $suf2)));
}


#-------------------------------------------------------------------------------------
#                        prob
#-------------------------------------------------------------------------------------

# prob(NUM, NUM, λ1, λ2);
#
# 機  能 : 補間した遷移確率を返す。

sub prob{
    (@_ == 5) || die "Markov->prob(...)";
    my($self, $suf1, $suf2, $L1, $L2) = @_;

    return($L1*$self->_1prob($suf2)+$L2*$self->_2prob($suf1, $suf2));
}


#-------------------------------------------------------------------------------------
#                        _0prob
#-------------------------------------------------------------------------------------

# _0prob(NUM);
#
# 機  能 : 一様分布による遷移確率を返す。

sub _0prob{
    (@_ == 1) || die;
    my($self) = @_;

    return(1/$self->size());
}


#-------------------------------------------------------------------------------------
#                        _1prob
#-------------------------------------------------------------------------------------

# _1prob(NUM);
#
# 機  能 : 0 重マルコフモデルによる遷移確率を返す。

sub _1prob{
    (@_ == 2) || die;
    my($self, $suf2) = @_;

    return($self->_1gram($suf2)/$self->_0gram());
}


#-------------------------------------------------------------------------------------
#                        _2prob
#-------------------------------------------------------------------------------------

# _2prob(NUM, NUM);
#
# 機  能 : 1 重マルコフモデルによる遷移確率を返す。

sub _2prob{
    (@_ == 3) || die;
    my($self, $suf1, $suf2) = @_;

    if ($self->_1gram($suf1) == 0){
        printf(STDERR "self->_1gram(%d) == 0\n", $suf1);
        die;
    }

    return($self->_2gram($suf1, $suf2)/$self->_1gram($suf1));
}


#-------------------------------------------------------------------------------------
#                        OneIteration
#-------------------------------------------------------------------------------------

# OneIteration(List, Lambda1, Lambda2)
#
# 機  能 : 補間係数推定の一回の繰り返し。
#
# 注意点 : List = [Scur, Sfol, Coef]

sub OneIteration{
    (@_ == 4) || die;
    my($self, $list, $L1, $L2) = @_;

    (@$list > 0) || return($L1, $L2);             # Held-out Data がない場合

    my($Scur, $Sfol, $Coef, $p1, $p2, $temp);
    my($Coef_sum, $L1_new, $L2_new) = (0, 0, 0);
    foreach (@$list){
        ($Scur, $Sfol, $Coef) = @$_;

        $p1 = $L1*$self->_1prob($Sfol);
        $p2 = $L2*$self->_2prob($Scur, $Sfol);
        $L1_new += $Coef*$p1/($p1+$p2);
        $L2_new += $Coef*$p2/($p1+$p2);
        $Coef_sum += $Coef;
    }

    $L1_new /= $Coef_sum;
    $L2_new /= $Coef_sum;

    $temp = 1-($L1_new+$L2_new);
    $L1_new += $temp/2;
    $L2_new += $temp/2;

    return($L1_new, $L2_new);
}


#-------------------------------------------------------------------------------------
#                        test
#-------------------------------------------------------------------------------------

sub test{
    # (@_ == 4) || die;
    # my($self, $IntStr) = (shift, shift);
    # my(@stat) = map($IntStr->int($_), @_);
    #
    # printf(STDERR "%s Markov->test %s\n", "-" x 4, "-" x 64);
    # printf(STDERR "  Freq(%s %s) = %f\n", @_, $self->_2gram(@stat));
    # printf(STDERR "  Freq(%s) = %f\n", @_[0], $self->_1gram(@stat[0]));
    # printf(STDERR "  Freq(%s) = %f\n", @_[1], $self->_1gram(@stat[1]));
    # printf(STDERR "  Freq() = %f\n", $self->_0gram());
}


#-------------------------------------------------------------------------------------
#                        return
#-------------------------------------------------------------------------------------

1;


#=====================================================================================
#                        END
#=====================================================================================
